<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module Review Report â€” f_core.mixins.hashable</title>
    <style>
        :root {
            --bg: #0b0f14;
            --bg-section: #121820;
            --bg-code: #1a2230;
            --border: #1e2a3a;
            --text: #c9d1d9;
            --text-muted: #8b949e;
            --heading: #e6edf3;
            --accent: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #bc8cff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            padding: 2rem;
            max-width: 960px;
            margin: 0 auto;
        }

        h1 {
            color: var(--heading);
            font-size: 1.8rem;
            border-bottom: 2px solid var(--accent);
            padding-bottom: 0.5rem;
            margin-bottom: 0.5rem;
        }

        h1 small {
            display: block;
            font-size: 0.9rem;
            color: var(--text-muted);
            font-weight: normal;
            margin-top: 0.25rem;
        }

        h2 {
            color: var(--accent);
            font-size: 1.35rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.3rem;
            border-bottom: 1px solid var(--border);
        }

        h3 {
            color: var(--accent-purple);
            font-size: 1.05rem;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        section {
            background: var(--bg-section);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        ul {
            padding-left: 1.25rem;
            margin: 0.5rem 0;
        }

        li {
            margin-bottom: 0.4rem;
        }

        pre {
            background: var(--bg-code);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 1rem;
            overflow-x: auto;
            font-family: "SF Mono", "Fira Code", "Fira Mono", Menlo, Consolas, monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            margin: 0.75rem 0;
            color: var(--text);
        }

        code {
            font-family: "SF Mono", "Fira Code", "Fira Mono", Menlo, Consolas, monospace;
            font-size: 0.85em;
            background: var(--bg-code);
            padding: 0.15em 0.4em;
            border-radius: 4px;
        }

        .tag {
            display: inline-block;
            padding: 0.1em 0.5em;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-right: 0.3rem;
        }

        .tag-ok { background: #1a3a2a; color: var(--accent-green); }
        .tag-info { background: #1a2a3a; color: var(--accent); }
        .tag-warn { background: #3a2a1a; color: var(--accent-yellow); }
        .tag-issue { background: #3a1a1a; color: var(--accent-red); }

        .dep-table {
            width: 100%;
            border-collapse: collapse;
            margin: 0.75rem 0;
        }

        .dep-table th,
        .dep-table td {
            text-align: left;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border);
        }

        .dep-table th {
            background: var(--bg-code);
            color: var(--heading);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .dep-table td {
            font-size: 0.9rem;
        }

        .verdict {
            margin-top: 0.75rem;
            padding: 0.5rem 0.75rem;
            border-left: 3px solid var(--accent-green);
            background: rgba(63, 185, 80, 0.05);
            font-style: italic;
            color: var(--text-muted);
        }

        .verdict-warn {
            border-left-color: var(--accent-yellow);
            background: rgba(210, 153, 34, 0.05);
        }

        p {
            margin: 0.5rem 0;
        }

        strong {
            color: var(--heading);
        }
    </style>
</head>
<body>

<h1>Module Review Report
    <small>f_core.mixins.hashable &mdash; reviewed 2026-02-11</small>
</h1>

<!-- ================================================================== -->
<!-- 0) DEPENDENCY MAP                                                  -->
<!-- ================================================================== -->
<section>
    <h2>0) Dependency Map</h2>

    <h3>Files Under Review</h3>
    <table class="dep-table">
        <tr>
            <th>File</th>
            <th>Lines</th>
            <th>Role</th>
        </tr>
        <tr>
            <td><code>main.py</code></td>
            <td>21</td>
            <td>Core <code>Hashable</code> mixin class</td>
        </tr>
        <tr>
            <td><code>_factory.py</code></td>
            <td>39</td>
            <td>Test factory producing concrete <code>Hashable</code> instances</td>
        </tr>
        <tr>
            <td><code>_tester.py</code></td>
            <td>13</td>
            <td>Smoke test using the factory</td>
        </tr>
        <tr>
            <td><code>__init__.py</code></td>
            <td>5</td>
            <td>Package init; re-exports <code>Hashable</code> and attaches <code>Factory</code></td>
        </tr>
    </table>

    <h3>Used Imports &mdash; Deep Inspection</h3>
    <table class="dep-table">
        <tr>
            <th>Source File</th>
            <th>Import</th>
            <th>Symbol(s) Used</th>
            <th>How Used</th>
        </tr>
        <tr>
            <td><code>main.py:1</code></td>
            <td><code>f_core.mixins.equatable.Equatable</code></td>
            <td><code>Equatable</code></td>
            <td>Direct base class of <code>Hashable</code>. Provides abstract <code>key()</code> and concrete <code>__eq__</code>.</td>
        </tr>
        <tr>
            <td><code>_factory.py:1</code></td>
            <td><code>f_core.mixins.hashable.Hashable</code></td>
            <td><code>Hashable</code></td>
            <td>Base class for the inner <code>Factory.Char</code> test class and return-type annotation for <code>a()</code>/<code>b()</code>.</td>
        </tr>
        <tr>
            <td><code>_tester.py:1</code></td>
            <td><code>f_core.mixins.hashable.Hashable</code></td>
            <td><code>Hashable</code></td>
            <td>Accessed via <code>Hashable.Factory.a()</code> and <code>Hashable.Factory.b()</code> to create instances for testing.</td>
        </tr>
        <tr>
            <td><code>__init__.py:1</code></td>
            <td><code>f_core.mixins.hashable.main.Hashable</code></td>
            <td><code>Hashable</code></td>
            <td>Re-exported as the public symbol of the package.</td>
        </tr>
        <tr>
            <td><code>__init__.py:2</code></td>
            <td><code>f_core.mixins.hashable._factory.Factory</code></td>
            <td><code>Factory</code></td>
            <td>Attached to <code>Hashable.Factory</code> at import time (monkey-patching the class attribute).</td>
        </tr>
    </table>

    <h3>Transitive Dependencies (inspected)</h3>
    <table class="dep-table">
        <tr>
            <th>Symbol</th>
            <th>Defined In</th>
            <th>Role</th>
        </tr>
        <tr>
            <td><code>Equatable</code></td>
            <td><code>f_core/mixins/equatable/main.py</code></td>
            <td>Implements <code>SupportsEquality</code> protocol. Declares abstract <code>key() -&gt; SupportsEquality</code> and concrete <code>__eq__</code> comparing via <code>key()</code>. Includes identity short-circuit (<code>other is self</code>) and <code>NotImplemented</code> fallback.</td>
        </tr>
        <tr>
            <td><code>SupportsEquality</code></td>
            <td><code>f_core/protocols/equality/main.py</code></td>
            <td><code>Protocol</code> declaring <code>__eq__(self, other: object) -&gt; bool</code>. Structural subtyping contract.</td>
        </tr>
    </table>

    <h3>Dependency Direction</h3>
    <pre>
SupportsEquality (Protocol)       &lt;-- f_core.protocols.equality
   ^
   |
Equatable (Mixin, abstract)       &lt;-- f_core.mixins.equatable
   ^
   |
Hashable  (Mixin, concrete)      &lt;-- f_core.mixins.hashable  [this module]
    </pre>
    <ul>
        <li><span class="tag tag-ok">OK</span> Direction: concrete depends on abstract; protocol at the bottom. Proper layering.</li>
        <li><span class="tag tag-ok">OK</span> No circular imports detected. <code>_factory.py</code> imports from the package <code>__init__.py</code>, which imports from <code>main.py</code>. The package init imports <code>_factory.py</code> after <code>main.py</code>, so no cycle.</li>
        <li><span class="tag tag-ok">OK</span> No inversion issues. Higher-level modules never import from <code>Hashable</code>.</li>
    </ul>
</section>

<!-- ================================================================== -->
<!-- SUMMARY                                                            -->
<!-- ================================================================== -->
<section>
    <h2>Summary</h2>
    <p>
        <code>Hashable</code> is a 21-line mixin that extends <code>Equatable</code> with a <code>__hash__</code>
        implementation delegating to the inherited abstract <code>key()</code> method. The design correctly maintains
        Python's invariant: <code>a == b</code> implies <code>hash(a) == hash(b)</code> because both <code>__eq__</code>
        and <code>__hash__</code> delegate to the same <code>key()</code> return value.
    </p>
    <p>
        The module is clean, focused, and well-layered. One minor typing observation and one minor documentation note
        are raised below. No correctness bugs found.
    </p>
</section>

<!-- ================================================================== -->
<!-- 1) CORRECTNESS                                                     -->
<!-- ================================================================== -->
<section>
    <h2>1) Must-fix Issues (Correctness)</h2>

    <h3>Analysis</h3>
    <ul>
        <li>
            <strong>Crash paths:</strong> <code>__hash__</code> (<code>main.py:20</code>) calls <code>hash(self.key())</code>.
            If a subclass returns an unhashable value from <code>key()</code> (e.g., a <code>list</code>), this will raise
            <code>TypeError: unhashable type</code> at runtime. However, this is <strong>not a bug in this module</strong> &mdash;
            it is a contract violation by the subclass. The <code>key()</code> return type is <code>SupportsEquality</code>,
            which does not constrain hashability at the type level. This is noted under Typing (Section 5) but is not a correctness
            defect of <code>Hashable</code> itself.
        </li>
        <li>
            <strong>Invariant (<code>__eq__</code> / <code>__hash__</code> consistency):</strong>
            Both <code>__eq__</code> (inherited from <code>Equatable</code>, <code>equatable/main.py:26-36</code>) and
            <code>__hash__</code> (<code>main.py:20</code>) delegate to <code>self.key()</code>. This ensures:
            <code>a == b</code> &rArr; <code>a.key() == b.key()</code> &rArr; <code>hash(a.key()) == hash(b.key())</code>
            &rArr; <code>hash(a) == hash(b)</code>. Invariant is correctly maintained.
        </li>
        <li>
            <strong>Edge case &mdash; <code>key()</code> returning <code>None</code>:</strong>
            <code>hash(None)</code> is valid in Python (returns <code>0</code> on CPython). No crash.
        </li>
        <li>
            <strong>Factory (<code>_factory.py</code>):</strong> <code>Factory.Char</code> returns a single <code>str</code>
            character from <code>key()</code> &mdash; strings are hashable. No issue.
        </li>
        <li>
            <strong>Tester (<code>_tester.py</code>):</strong> <code>assert {a, a, b} == {a, b}</code> correctly
            exercises set deduplication which depends on both <code>__eq__</code> and <code>__hash__</code>. Correct test.
        </li>
    </ul>

    <div class="verdict">No correctness issues found. No change needed.</div>
</section>

<!-- ================================================================== -->
<!-- 2) READABILITY                                                     -->
<!-- ================================================================== -->
<section>
    <h2>2) Readability / Maintainability</h2>

    <ul>
        <li>
            <span class="tag tag-ok">OK</span>
            <strong>Naming:</strong> <code>Hashable</code> is precise. It is the project's own mixin &mdash; not
            <code>collections.abc.Hashable</code> &mdash; and the module path (<code>f_core.mixins.hashable</code>)
            makes this unambiguous.
        </li>
        <li>
            <span class="tag tag-ok">OK</span>
            <strong>Nesting:</strong> Zero nesting in <code>main.py</code>. The <code>__hash__</code> method is a
            single-expression one-liner. Maximum clarity.
        </li>
        <li>
            <span class="tag tag-ok">OK</span>
            <strong>File length:</strong> 21 lines for <code>main.py</code>. Ideal for fast re-entry.
        </li>
        <li>
            <span class="tag tag-ok">OK</span>
            <strong>Responsibilities:</strong> Each file has a single job: <code>main.py</code> = class,
            <code>_factory.py</code> = test data, <code>_tester.py</code> = test, <code>__init__.py</code> = wiring.
        </li>
        <li>
            <span class="tag tag-info">NOTE</span>
            <strong><code>_factory.py:19</code> &mdash; <code>Factory.Char.key()</code> return type:</strong>
            The return annotation is <code>-&gt; str</code>, which is correct and more specific than the abstract
            declaration (<code>-&gt; SupportsEquality</code>). This is fine in Python (covariant override of the
            return type). No change needed.
        </li>
    </ul>

    <div class="verdict">No change needed.</div>
</section>

<!-- ================================================================== -->
<!-- 3) DESIGN (OOP)                                                    -->
<!-- ================================================================== -->
<section>
    <h2>3) Design Review</h2>

    <h3>Abstraction Boundaries</h3>
    <ul>
        <li>
            <span class="tag tag-ok">OK</span>
            <strong>Mixin pattern:</strong> <code>Hashable</code> adds exactly one capability (<code>__hash__</code>)
            on top of <code>Equatable</code>. Clean single-responsibility mixin.
        </li>
        <li>
            <span class="tag tag-ok">OK</span>
            <strong>Inheritance depth:</strong>
            <code>SupportsEquality</code> &rarr; <code>Equatable</code> &rarr; <code>Hashable</code>.
            Depth of 3, which is manageable. Each level adds exactly one semantic layer.
        </li>
    </ul>

    <h3>SRP</h3>
    <ul>
        <li>
            <span class="tag tag-ok">OK</span>
            <code>Hashable</code> has exactly one responsibility: provide <code>__hash__</code> delegating to <code>key()</code>.
        </li>
    </ul>

    <h3>Factory Attachment Pattern</h3>
    <ul>
        <li>
            <span class="tag tag-info">NOTE</span>
            The <code>Factory</code> class is monkey-patched onto <code>Hashable</code> at import time
            (<code>__init__.py:4</code>: <code>Hashable.Factory = Factory</code>). This is a project-wide pattern
            also used in <code>Equatable</code> (<code>equatable/__init__.py:4</code>). Consistent. The class
            attribute <code>Factory: type | None = None</code> (<code>main.py:12</code>) serves as a forward
            declaration / placeholder. This keeps the main class free of test concerns.
        </li>
    </ul>

    <h3>Dependency Direction</h3>
    <ul>
        <li>
            <span class="tag tag-ok">OK</span>
            Concrete &rarr; Abstract &rarr; Protocol. Correct direction throughout.
        </li>
    </ul>

    <div class="verdict">No change needed.</div>
</section>

<!-- ================================================================== -->
<!-- 4) PERFORMANCE                                                     -->
<!-- ================================================================== -->
<section>
    <h2>4) Performance Notes</h2>

    <h3>Big-O Analysis</h3>
    <table class="dep-table">
        <tr>
            <th>Method</th>
            <th>Time</th>
            <th>Space</th>
            <th>Notes</th>
        </tr>
        <tr>
            <td><code>__hash__</code></td>
            <td>O(T<sub>key</sub> + T<sub>hash</sub>)</td>
            <td>O(1)</td>
            <td>Dominated by <code>key()</code> computation and the built-in <code>hash()</code> of that value.
                For typical keys (strings, tuples of primitives), this is O(n) where n = key size.</td>
        </tr>
        <tr>
            <td><code>__eq__</code> (inherited)</td>
            <td>O(T<sub>key</sub>)</td>
            <td>O(1)</td>
            <td>Identity check (<code>is</code>) short-circuits in O(1).</td>
        </tr>
    </table>

    <h3>Hot Path Consideration</h3>
    <p>
        <code>__hash__</code> calls <code>self.key()</code> on every hash lookup. If <code>key()</code> is expensive
        (e.g., computes a tuple from many fields), and instances are used heavily in sets/dicts, caching the hash value
        could be beneficial. However, that is a subclass-level optimization concern, not something <code>Hashable</code>
        itself should enforce &mdash; it would break the mixin's generality.
    </p>

    <div class="verdict">No change needed.</div>
</section>

<!-- ================================================================== -->
<!-- 5) TYPING                                                          -->
<!-- ================================================================== -->
<section>
    <h2>5) Typing Review</h2>

    <h3>Observation: <code>key()</code> return type vs. hashability</h3>
    <ul>
        <li>
            <span class="tag tag-warn">TYPING</span>
            <strong>Evidence:</strong> <code>equatable/main.py:18</code> declares <code>key(self) -&gt; SupportsEquality</code>.
            <code>SupportsEquality</code> (<code>protocols/equality/main.py:4</code>) is a <code>Protocol</code> requiring
            only <code>__eq__</code>. It does not require <code>__hash__</code>.
        </li>
        <li>
            <strong>Impact:</strong> A subclass of <code>Hashable</code> could return a <code>list</code> from <code>key()</code>
            (which satisfies <code>SupportsEquality</code>), and mypy would not flag it, but <code>hash()</code> would fail
            at runtime.
        </li>
        <li>
            <strong>Why this is acceptable as-is:</strong> The <code>key()</code> method is defined on <code>Equatable</code>,
            which is also the base for <code>Comparable</code> and potentially other mixins. Narrowing its return type to
            <code>typing.Hashable</code> on the <code>Equatable</code> level would over-constrain non-hashing use cases.
            Overriding the return type in <code>Hashable</code> alone would violate Liskov Substitution (contravariance of
            return types in Protocol contexts is tricky).
        </li>
        <li>
            <strong>Possible improvement (low priority):</strong> A <code>SupportsHash</code> protocol
            (requiring both <code>__eq__</code> and <code>__hash__</code>) could be introduced, and <code>Hashable</code>
            could override <code>key()</code> with a narrower return type annotation. This is a design trade-off &mdash; it
            adds a protocol just for type safety on a contract that is already implied by the class name. Documenting the
            requirement (as is done in CLAUDE.md) may be sufficient.
        </li>
    </ul>

    <h3>Coverage Check</h3>
    <table class="dep-table">
        <tr>
            <th>Symbol</th>
            <th>Fully Typed?</th>
        </tr>
        <tr>
            <td><code>Hashable.__hash__(self) -&gt; int</code></td>
            <td><span class="tag tag-ok">YES</span></td>
        </tr>
        <tr>
            <td><code>Hashable.Factory: type | None</code></td>
            <td><span class="tag tag-ok">YES</span></td>
        </tr>
        <tr>
            <td><code>Factory.a() -&gt; Hashable</code></td>
            <td><span class="tag tag-ok">YES</span></td>
        </tr>
        <tr>
            <td><code>Factory.b() -&gt; Hashable</code></td>
            <td><span class="tag tag-ok">YES</span></td>
        </tr>
        <tr>
            <td><code>Factory.Char.__init__(self, char: str)</code></td>
            <td><span class="tag tag-ok">YES</span></td>
        </tr>
        <tr>
            <td><code>Factory.Char.key(self) -&gt; str</code></td>
            <td><span class="tag tag-ok">YES</span></td>
        </tr>
        <tr>
            <td><code>test_hashable() -&gt; None</code></td>
            <td><span class="tag tag-ok">YES</span></td>
        </tr>
    </table>

    <div class="verdict">
        All public APIs are fully typed. The <code>key()</code> return type gap is a known design trade-off
        documented in CLAUDE.md. No immediate change needed.
    </div>
</section>

<!-- ================================================================== -->
<!-- 6) DOCUMENTATION                                                   -->
<!-- ================================================================== -->
<section>
    <h2>6) Documentation Review</h2>

    <h3>Class Docstring &mdash; <code>main.py:6-9</code></h3>
    <ul>
        <li>
            <span class="tag tag-warn">MINOR</span>
            Current: <em>"Mixin for hashable objects (has distinct value for each instance)."</em>
        </li>
        <li>
            The parenthetical <em>"has distinct value for each instance"</em> is misleading. Two instances with
            the same <code>key()</code> will have the same hash &mdash; that is the whole point. "Distinct" implies
            uniqueness, which is the opposite of the contract. The docstring on <code>__hash__</code> is fine.
        </li>
        <li>
            <strong>Suggested rewrite:</strong>
<pre>"""
============================================================================
 Mixin for objects that support hashing via the inherited key() method.
 Guarantees: a == b implies hash(a) == hash(b).
============================================================================
"""</pre>
        </li>
    </ul>

    <h3>Method Docstring &mdash; <code>main.py:15-19</code></h3>
    <ul>
        <li>
            <span class="tag tag-ok">OK</span>
            <em>"Return the hash of the object."</em> &mdash; Accurate and concise. Matches the single-line
            implementation. No change needed.
        </li>
    </ul>

    <h3>Factory Docstrings</h3>
    <ul>
        <li>
            <span class="tag tag-ok">OK</span>
            All factory methods and the <code>Char</code> inner class have adequate docstrings.
        </li>
    </ul>

    <h3>Tester Docstring</h3>
    <ul>
        <li>
            <span class="tag tag-ok">OK</span>
            <code>_tester.py:4-9</code> has a docstring. Adequate for a smoke test.
        </li>
    </ul>

    <div class="verdict verdict-warn">
        One minor docstring improvement suggested for the class-level docstring in <code>main.py</code>.
        The parenthetical "has distinct value for each instance" is inaccurate.
    </div>
</section>

<!-- ================================================================== -->
<!-- 7) MODULARITY                                                      -->
<!-- ================================================================== -->
<section>
    <h2>7) Modularity</h2>

    <ul>
        <li>
            <span class="tag tag-ok">OK</span>
            <strong>File focus:</strong> Every file in this package has a single, clear purpose.
            <ul>
                <li><code>main.py</code> (21 lines) &mdash; the mixin class</li>
                <li><code>_factory.py</code> (39 lines) &mdash; test data factory</li>
                <li><code>_tester.py</code> (13 lines) &mdash; smoke test</li>
                <li><code>__init__.py</code> (5 lines) &mdash; package wiring</li>
            </ul>
        </li>
        <li>
            <span class="tag tag-ok">OK</span>
            <strong>No overloaded modules.</strong> No file does more than one thing.
        </li>
        <li>
            <span class="tag tag-ok">OK</span>
            <strong>No dumping grounds.</strong> Underscore-prefixed private modules (<code>_factory</code>,
            <code>_tester</code>) are correctly hidden from public API.
        </li>
        <li>
            <span class="tag tag-ok">OK</span>
            <strong>Consistent with sibling modules.</strong> The <code>equatable</code> package follows
            the exact same 4-file structure: <code>main.py</code>, <code>_factory.py</code>, <code>_tester.py</code>,
            <code>__init__.py</code>.
        </li>
    </ul>

    <div class="verdict">No change needed.</div>
</section>

<!-- ================================================================== -->
<!-- 8) ARCHITECTURE (CROSS-MODULE)                                     -->
<!-- ================================================================== -->
<section>
    <h2>8) Architecture Findings</h2>

    <h3>Pattern Consistency</h3>
    <ul>
        <li>
            <span class="tag tag-ok">OK</span>
            <strong>Mixin chain:</strong> <code>SupportsEquality</code> &rarr; <code>Equatable</code> &rarr;
            <code>Hashable</code> follows a consistent pattern where each level adds one capability.
            CLAUDE.md mentions <code>Comparable</code> as another sibling of <code>Hashable</code> under
            <code>Equatable</code>. The <code>key()</code> method is the shared abstraction point for all three
            behaviors (equality, comparison, hashing). This is a sound design.
        </li>
        <li>
            <span class="tag tag-ok">OK</span>
            <strong>Factory attachment pattern:</strong> Identical in <code>hashable/__init__.py</code> and
            <code>equatable/__init__.py</code>: import main class, import factory, assign
            <code>Class.Factory = Factory</code>. Consistent cross-module pattern.
        </li>
        <li>
            <span class="tag tag-ok">OK</span>
            <strong>Protocol at the base:</strong> <code>SupportsEquality</code> is a <code>Protocol</code>,
            enabling structural subtyping for external code that does not inherit from <code>Equatable</code>.
            Good architectural decision.
        </li>
    </ul>

    <h3>Potential Cross-Module Concern</h3>
    <ul>
        <li>
            <span class="tag tag-info">NOTE</span>
            <strong><code>Equatable.__eq__</code> returns <code>NotImplemented</code> for non-<code>Equatable</code> types</strong>
            (<code>equatable/main.py:35</code>). This is correct Python behavior &mdash; it lets the other operand's
            <code>__eq__</code> handle the comparison. This means <code>Hashable</code> instances compared against
            plain Python objects will fall back properly. No issue.
        </li>
        <li>
            <span class="tag tag-info">NOTE</span>
            <strong>The <code>key()</code> rename from <code>key_comparison()</code></strong> was recent per the
            user's notes. As long as all subclasses across the codebase have been updated, no issue. This review
            covers only the <code>hashable</code> module, which uses the new name consistently.
        </li>
    </ul>

    <div class="verdict">No change needed.</div>
</section>

<!-- ================================================================== -->
<!-- 9) SUGGESTIONS                                                     -->
<!-- ================================================================== -->
<section>
    <h2>9) Suggestions for Improvements</h2>

    <table class="dep-table">
        <tr>
            <th>#</th>
            <th>Priority</th>
            <th>Item</th>
            <th>Evidence</th>
            <th>Risk/Cost</th>
            <th>Benefit</th>
            <th>Change</th>
        </tr>
        <tr>
            <td>1</td>
            <td><span class="tag tag-warn">LOW</span></td>
            <td>Fix misleading class docstring</td>
            <td><code>main.py:7</code> &mdash; "has distinct value for each instance" implies unique hashes, which contradicts the <code>__eq__</code>/<code>__hash__</code> invariant.</td>
            <td>Zero risk. One-line change.</td>
            <td>Eliminates confusion on re-entry. Accurate mental model.</td>
            <td>
                Replace with:
<pre>"""
============================================================================
 Mixin for objects that support hashing via the inherited key() method.
 Guarantees: a == b implies hash(a) == hash(b).
============================================================================
"""</pre>
            </td>
        </tr>
        <tr>
            <td>2</td>
            <td><span class="tag tag-info">OPTIONAL</span></td>
            <td>Consider a <code>SupportsHash</code> protocol (strategic)</td>
            <td><code>equatable/main.py:18</code> &mdash; <code>key() -&gt; SupportsEquality</code> does not enforce hashability of the returned value.</td>
            <td>Adds a new protocol file. Moderate cost for marginal type-safety gain.</td>
            <td>Would catch unhashable <code>key()</code> returns at type-check time for <code>Hashable</code> subclasses.</td>
            <td>
                Create <code>f_core/protocols/hashability/main.py</code> with a <code>SupportsHash(Protocol)</code>
                requiring <code>__eq__</code> and <code>__hash__</code>. Override <code>key()</code> return type
                in <code>Hashable</code> to <code>-&gt; SupportsHash</code>. Only pursue if the codebase has
                experienced bugs from unhashable keys.
            </td>
        </tr>
    </table>

    <p>
        Beyond the docstring fix, no improvements needed. The module is clean, correct, well-typed,
        and consistent with the project's established patterns.
    </p>
</section>

</body>
</html>
