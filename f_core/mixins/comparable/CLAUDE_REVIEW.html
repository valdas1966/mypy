<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Code Review â€” Comparable</title>
<style>
:root {
    --bg: #0b0f14;
    --panel: #111827;
    --panel2: #0f172a;
    --text: #f8fafc;
    --muted: #cbd5e1;
    --faint: #94a3b8;
    --border: #334155;
    --accent: #60a5fa;
    --accent2: #a78bfa;
    --good: #34d399;
    --warn: #fbbf24;
    --bad: #fb7185;
    --code-bg: #0a1220;
}
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.7;
    padding: 2rem 3rem;
    max-width: 960px;
    margin: 0 auto;
}
a { color: var(--accent); text-decoration: none; }
a:hover { color: var(--accent2); text-decoration: underline; }
h1 { color: #fff; font-size: 2rem; margin-bottom: .3rem; }
.path {
    color: var(--faint);
    font-family: monospace;
    font-size: .9rem;
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 2px solid var(--border);
}
h2 {
    color: #fff;
    font-size: 1.4rem;
    margin: 2.5rem 0 1rem;
    padding-bottom: .4rem;
    border-bottom: 2px solid var(--border);
}
h3 { color: var(--text); font-size: 1.1rem; margin: 1.5rem 0 .5rem; }
ol { padding-left: 1.5rem; margin: .75rem 0; }
li { margin-bottom: .6rem; color: var(--muted); }
li strong { color: var(--text); }
p { margin-bottom: .75rem; color: var(--muted); }
pre {
    background: var(--code-bg);
    border: 2px solid var(--border);
    border-radius: 6px;
    padding: 1rem;
    overflow-x: auto;
    margin: .75rem 0;
}
code {
    font-family: 'SF Mono', Monaco, 'Cascadia Code', Consolas, monospace;
    font-size: .9rem;
    color: var(--text);
}
pre code { display: block; line-height: 1.5; }
.ic {
    background: var(--panel2);
    padding: .15rem .4rem;
    border-radius: 3px;
    font-size: .85rem;
}
.v {
    display: inline-block;
    padding: .2rem .6rem;
    border-radius: 4px;
    font-size: .8rem;
    font-weight: 600;
}
.v-pass { background: var(--good); color: var(--bg); }
.v-minor { background: var(--warn); color: var(--bg); }
.fr { color: var(--accent); font-family: monospace; font-size: .85rem; }
.note {
    background: var(--panel2);
    border-left: 3px solid var(--accent);
    padding: .75rem 1rem;
    margin: 1rem 0;
    color: var(--muted);
    font-size: .9rem;
}
.note-good { border-left-color: var(--good); }
.note-warn { border-left-color: var(--warn); }
table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
th, td { padding: .75rem; text-align: left; border: 1px solid var(--border); }
th { background: var(--panel2); color: #fff; font-weight: 600; }
td { background: var(--panel); color: var(--muted); }
footer {
    margin-top: 3rem;
    padding-top: 1.5rem;
    border-top: 2px solid var(--border);
    color: var(--faint);
    font-size: .85rem;
}
</style>
</head>
<body>

<h1>Code + Design Review</h1>
<div class="path">f_core / mixins / comparable</div>
<p>
    Files reviewed:
    <code class="ic">main.py</code>,
    <code class="ic">_factory.py</code>,
    <code class="ic">_tester.py</code>,
    <code class="ic">__init__.py</code>
</p>
<p>
    Deep-inspected:
    <code class="ic">Equatable</code>,
    <code class="ic">SupportsComparison</code>,
    <code class="ic">SupportsEquality</code>
</p>

<!-- ======== 1. Correctness ======== -->
<section>
    <h2>1. Correctness</h2>
    <p class="note note-good">No change needed.</p>
    <ol>
        <li>
            All four comparison operators directly delegate to
            <code class="ic">self.key &lt;op&gt; other.key</code>.
            No type guards by design &mdash; cross-type comparison
            raises <code class="ic">AttributeError</code>.
        </li>
        <li>
            <code class="ic">__eq__</code> inherited from
            <code class="ic">Equatable</code> works correctly with
            the covariant <code class="ic">key</code> override.
        </li>
    </ol>
</section>

<!-- ======== 2. Readability / Naming ======== -->
<section>
    <h2>2. Readability / Naming</h2>
    <ol>
        <li>
            <strong><span class="fr">__init__.py:1</span></strong>
            &mdash; Imports <code class="ic">Comparable</code>
            indirectly from <code class="ic">_factory.py</code>
            instead of directly from <code class="ic">main.py</code>.
            Inconsistent with equatable's convention.
<pre><code># current
from f_core.mixins.comparable._factory import Factory, Comparable

# convention (matches equatable/__init__.py)
from f_core.mixins.comparable.main import Comparable
from f_core.mixins.comparable._factory import Factory</code></pre>
        </li>
    </ol>
</section>

<!-- ======== 3. Design (OOP) ======== -->
<section>
    <h2>3. Design (OOP)</h2>
    <p class="note note-good">No change needed.</p>
    <ol>
        <li>
            Dual inheritance
            (<code class="ic">Equatable</code> +
            <code class="ic">SupportsComparison</code>) mirrors
            the protocol hierarchy cleanly.
        </li>
        <li>
            <code class="ic">key</code> narrows from
            <code class="ic">SupportsEquality</code> to
            <code class="ic">SupportsComparison</code> &mdash;
            covariant return, Liskov-compliant.
        </li>
        <li>
            Explicit operator implementations instead of
            <code class="ic">@total_ordering</code> &mdash;
            correct performance-driven decision for a search
            algorithm framework.
        </li>
    </ol>
</section>

<!-- ======== 4. Performance ======== -->
<section>
    <h2>4. Performance</h2>
    <p class="note note-good">No change needed.</p>
    <ol>
        <li>
            Each comparison: exactly 2
            <code class="ic">key</code> accesses, no
            <code class="ic">isinstance</code>, no indirection.
            Optimal for hot-path usage (heap operations, sorting).
        </li>
    </ol>
</section>

<!-- ======== 5. Typing ======== -->
<section>
    <h2>5. Typing</h2>
    <p class="note note-good">No change needed.</p>
    <ol>
        <li>
            All public signatures fully typed.
            <code class="ic">key</code> returns
            <code class="ic">SupportsComparison</code>,
            correctly narrowing the parent's
            <code class="ic">SupportsEquality</code>.
            Factory methods return
            <code class="ic">Comparable</code>.
        </li>
    </ol>
</section>

<!-- ======== 6. Documentation ======== -->
<section>
    <h2>6. Documentation</h2>
    <p class="note note-good">No change needed.</p>
    <ol>
        <li>
            Class and method docstrings follow the project's
            <code class="ic">====</code> separator convention.
        </li>
    </ol>
</section>

<!-- ======== 7. Modularity ======== -->
<section>
    <h2>7. Modularity</h2>
    <p class="note note-good">No change needed.</p>
    <ol>
        <li>
            Standard 4-file layout. All files short and focused.
        </li>
    </ol>
</section>

<!-- ======== 8. Architecture ======== -->
<section>
    <h2>8. Architecture</h2>
    <p class="note note-good">No change needed.</p>
    <ol>
        <li>
            Protocol hierarchy
            (<code class="ic">SupportsEquality</code> &rarr;
            <code class="ic">SupportsComparison</code>) is correctly
            mirrored by the mixin hierarchy
            (<code class="ic">Equatable</code> &rarr;
            <code class="ic">Comparable</code>).
            Acyclic dependencies.
        </li>
    </ol>
</section>

<!-- ======== 9. Usage & Usefulness ======== -->
<section>
    <h2>9. Usage &amp; Usefulness</h2>
    <ol>
        <li>
            <strong>How to use:</strong> inherit from
            <code class="ic">Comparable</code>, implement
            <code class="ic">key</code> property.
            All six comparison operators work automatically.
        </li>
        <li>
            <strong>When useful:</strong> any domain object that
            needs ordering (priority queues, sorted collections,
            search states, graph nodes with costs).
        </li>
        <li>
            <strong>Overengineered?</strong> No. Central to the
            search algorithm framework. Eliminates 5 dunder methods
            per subclass.
        </li>
        <li>
            <strong>Alternative:</strong>
            <code class="ic">dataclasses(order=True)</code> generates
            comparison methods but requires all fields in fixed order
            and doesn't support the
            single-<code class="ic">key</code> indirection.
            Current design is the right fit.
        </li>
    </ol>
</section>

<!-- ======== 10. Suggestions ======== -->
<section>
    <h2>10. Suggestions</h2>
    <table>
        <thead>
            <tr>
                <th>#</th><th>Item</th><th>Evidence</th>
                <th>Risk</th><th>Benefit</th><th>Fix</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td>Import <code class="ic">Comparable</code>
                    from <code class="ic">main.py</code> in
                    <code class="ic">__init__.py</code></td>
                <td><span class="fr">__init__.py:1</span></td>
                <td>None</td>
                <td>Consistent with equatable pattern;
                    explicit dependency</td>
                <td>Split import into two lines</td>
            </tr>
        </tbody>
    </table>
</section>

<!-- ======== Summary ======== -->
<section>
    <h2>Summary</h2>
    <ol>
        <li>
            <span class="v v-pass">CLEAN</span>
            Code is correct, minimal, and performance-optimized.
        </li>
        <li>
            One minor inconsistency:
            <code class="ic">__init__.py</code> imports
            <code class="ic">Comparable</code> indirectly from
            <code class="ic">_factory.py</code>.
        </li>
        <li>
            No bugs, no typing issues, no performance concerns.
        </li>
        <li>
            Test coverage is thorough: all 5 comparison operators
            tested.
        </li>
    </ol>
</section>

<footer>
    <p>Review date: 2026-02-24</p>
    <p>Scope: <code class="ic">f_core.mixins.comparable</code>
       (4 files)</p>
</footer>

</body>
</html>
